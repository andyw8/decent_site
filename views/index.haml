%h1 Why use Decent Exposure?

%p
  Rails controllers are the sweaty armpit of every rails app. This is due, in
  large part, to the fact that they expose their instance variables directly to
  their views. This means that your instance variables are your interface...
  and that you've broken encapsulation. Instance variables are meant to be
  private, for Science's sake!

%p What <code>decent_exposure</code> proposes is that you go from this:

%pre
  %code
    :plain
      class Controller
        def new
          @person = Person.new(params[:person])
        end

        def create
          @person = Person.new(params[:person])
          if @person.save
            redirect_to(@person)
          else
            render :new
          end
        end

        def edit
          @person = Person.find(params[:id])
        end

        def update
          @person = Person.find(params[:id])
          if @person.update_attributes(params[:person])
            redirect_to(@person)
          else
            render :edit
          end
        end
      end

%p To something like this:

%pre
  %code
    :plain
      class Controller
        expose(:person)

        def create
          if person.save
            redirect_to(person)
          else
            render :new
          end
        end

        def update
          if person.save
            redirect_to(person)
          else
            render :edit
          end
        end
      end

%p
  <code>decent_exposure</code> makes it easy to define named methods that are
  made available to your views and which memoize the resultant values. It also
  tucks away the details of the common fetching, initializing and updating of
  resources and their parameters.

%p
  That's neat and all, but the real advantage comes when it's time to refactor
  (because you've encapsulated now). What happens when you need to scope your
  <code>Person</code> resource from a <code>Company</code>? Which
  implementation isolates those changes better? In that particular example,
  <code>decent_exposure</code> goes one step farther and will handle the
  scoping for you (with a smidge of configuration) while still handling all
  that repetitive initialization, as we'll see next.

%p
  Even if you decide not to use <code>decent_exposure</code>, do yourself a
  favor and stop using instance variables in your views. Your code will be
  cleaner and easier to refactor as a result. If you want to learn more about
  his approach, I've expanded on my thoughts in the article <a
  href='http://blog.voxdolo.me/a-diatribe-on-maintaining-state.html'> A
  Diatribe on Maintaining State </a>.

%h2 Environmental Awareness

%p
  Well, no it won't lessen your carbon footprint, but it does take a lot of
  cues from what's going on around it...

%p
  <code>decent_exposure</code> will build the requested object in one of a
  couple of ways depending on what the <code>params</code> make available to
  it. At its simplest, when an <code>id</code> is present in the
  <code>params</code> hash, <code>decent_exposure</code> will attempt to find a
  record. In absence of </code>params[:id]</code> <code>decent_exposure</code>
  will try to build a new record.

%p
  Once the object has been obtained, it attempts to set the attributes of the
  resulting object. Thus, a newly minted `person` instance will get any
  attributes set that've been passed along in `params[:person]`.  When you
  interact with `person` in your create action, just call save on it and handle
  the valid/invalid branch. Let's revisit our previous example:

%pre
  %code
    :plain
      class Controller
        expose(:person)

        def create
          if person.save
            redirect_to(person)
          else
            render :new
          end
        end
      end

%p Behind the scenes, `decent_exposure` has essentially done this:

%pre
  %code
    :plain
      person.attributes = params[:person]

%p
  In Rails, this assignment is actually a merge with the current attributes and
  it marks attributes as dirty as you would expect. This is why you're simply
  able to call `save` on the `person` instance in the create action, rather than
  the typical `update_attributes(params[:person])`.

%p
  %b An Aside

%p
  Did you notice there's no `new` action? Yeah, that's because we don't need it.
  More often than not actions that respond to `GET` requests are just setting up
  state. Since we've declared an interface to our state and made it available to
  the view (a.k.a. the place where we actually want to access it), we just let
  Rails do it's magic and render the `new` view, lazily evaluating `person` when
  we actually need it.

%p
  %b A Caveat

%p
  Rails conveniently responds with a 404 if you get a record not found in the
  controller. Since we don't find the object until we're in the view in this
  paradigm, we get an ugly `ActionView::TemplateError` instead. If this is
  problematic for you, consider using the `expose!` method to circumvent lazy
  evaluation and eagerly evaluate whilst still in the controller.
